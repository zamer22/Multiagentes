# -*- coding: utf-8 -*-
"""Copia de Cruce_Experimentos_Listo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1X5-VhnmKEfgenBftfduJN6XopyOy3GTF

# **0) Preparación**
"""

!pip install -q agentpy numpy pandas matplotlib seaborn

"""# **1) Imports y estilo**"""

import agentpy as ap
import numpy as np
import pandas as pd
import seaborn as sns
from matplotlib import pyplot as plt
sns.set(context="notebook", style="whitegrid")

"""# **2) Parámetros del experimento**"""

PARAMS = {
    'steps': 200,          # duración en ticks (1 tick = 1 s)
    'green_ns': 30,
    'green_ew': 30,
    'yellow': 3,
    'all_red': 2,

    # Tasas Poisson de arribo (veh/s) por aproximación
    'lambda_N': 0.10,
    'lambda_S': 0.12,
    'lambda_E': 0.06,
    'lambda_W': 0.08,

    # Cinemática
    'v_free': 7.0,        # m/s
    'headway': 7.0,       # m separación mínima

    # Geometría
    'L': 80.0,            # largo medio
    'w': 3.5,             # ancho carril
    'roundabout_radius': 15.0,  # radio rotonda
    'stop_dist': 5.0      # distancia de línea de alto
}

"""# **3) Controladores de semáforo**
3.1. Utilidades comunes
"""

def lights_from_phase_sub(phase, sub):
    L = {d:'R' for d in ['N','S','E','W']}
    if sub == 'AR':
        return L
    if phase == 0:
        L['N'] = L['S'] = sub
    else:
        L['E'] = L['W'] = sub
    return L

class FixedController(ap.Agent):
    """Plan fijo: phase 0 = N+S green, phase 1 = E+W green (G->Y->AR)"""
    def setup(self, green_ns, green_ew, yellow, all_red):
        self.g_ns, self.g_ew = int(green_ns), int(green_ew)
        self.y, self.ar = int(yellow), int(all_red)
        self.phase, self.sub, self.t_in = 0, 'G', 0
        self.timeline = []

    def step(self):
        self.timeline.append((self.model.t, self.phase, self.sub, lights_from_phase_sub(self.phase, self.sub)))
        if self.phase == 0:
            if self.sub == 'G' and self.t_in >= self.g_ns:
                self.sub, self.t_in = 'Y', 0
            elif self.sub == 'Y' and self.t_in >= self.y:
                self.sub, self.t_in = 'AR', 0
            elif self.sub == 'AR' and self.t_in >= self.ar:
                self.phase, self.sub, self.t_in = 1, 'G', 0
            else:
                self.t_in += 1
        else:
            if self.sub == 'G' and self.t_in >= self.g_ew:
                self.sub, self.t_in = 'Y', 0
            elif self.sub == 'Y' and self.t_in >= self.y:
                self.sub, self.t_in = 'AR', 0
            elif self.sub == 'AR' and self.t_in >= self.ar:
                self.phase, self.sub, self.t_in = 0, 'G', 0
            else:
                self.t_in += 1

    def lights(self):
        return lights_from_phase_sub(self.phase, self.sub)

    @property
    def green_dirs(self):
        return {'N','S'} if (self.phase==0 and self.sub=='G') else ({'E','W'} if (self.phase==1 and self.sub=='G') else set())

"""3.2. Controlador BASE (plan fijo)"""

class Car(ap.Agent):
    def setup(self, origin):
        p = self.model.p
        L, w = p.L, p.w
        self.origin = origin
        self.state = 'move'
        self.v = p.v_free

        if origin == 'N':
            self.pos = np.array([0.0, +L]);  self.dir = np.array([0.0, -1.0])
            self.stop = np.array([0.0, p.roundabout_radius + p.stop_dist])
            self.goal = np.array([0.0, -L])
        elif origin == 'S':
            self.pos = np.array([0.0, -L]);  self.dir = np.array([0.0, +1.0])
            self.stop = np.array([0.0, -(p.roundabout_radius + p.stop_dist)])
            self.goal = np.array([0.0, +L])
        elif origin == 'E':
            self.pos = np.array([+L, 0.0]);  self.dir = np.array([-1.0, 0.0])
            self.stop = np.array([p.roundabout_radius + p.stop_dist, 0.0])
            self.goal = np.array([-L, 0.0])
        else:  # 'W'
            self.pos = np.array([-L, 0.0]);  self.dir = np.array([+1.0, 0.0])
            self.stop = np.array([-(p.roundabout_radius + p.stop_dist), 0.0])
            self.goal = np.array([+L, 0.0])

        self.arrival_t = self.model.t

    def step(self):
        if np.linalg.norm(self.pos - self.goal) < 1.0:
            delay = self.model.t - self.arrival_t
            self.model.departures_log.append((self.model.t, self.origin, self.id, delay))
            self.state = 'done'
            return

        near = np.linalg.norm(self.pos - self.stop) < 8.0
        light = self.model.ctrl.lights()[self.origin]
        if near and light != 'G':
            return

        leader = self.model.leader_ahead(self)
        vmax = self.v
        if leader is not None:
            gap = np.linalg.norm(leader.pos - self.pos)
            if gap < self.model.p.headway:
                vmax = 0.0

        self.pos = self.pos + self.dir * vmax

class IntersectionModel(ap.Model):
    def setup(self, controller='fixed'):
        p = self.p
        self.ctrl = FixedController(self, p.green_ns, p.green_ew, p.yellow, p.all_red)
        self.cars = ap.AgentList(self, 0, Car)

        self.arrivals_log, self.departures_log = [], []
        self.queue_log, self.pos_log = [], []

    def leader_ahead(self, me):
        same = [c for c in self.cars if c is not me and np.allclose(c.dir, me.dir)]
        ahead = []
        for c in same:
            v = c.pos - me.pos
            proj = np.dot(v, me.dir)
            if proj > 0: ahead.append((proj, c))
        if not ahead: return None
        return min(ahead, key=lambda x: x[0])[1]

    def spawn_poisson(self, origin, lam):
        k = np.random.poisson(lam)
        for _ in range(k):
            v = Car(self, origin=origin)
            self.cars.append(v)
            self.arrivals_log.append((self.t, origin, v.id))

    def peek_queues(self):
        near = 12.0; p = self.p
        qN = sum(np.linalg.norm(c.pos - np.array([0.0, p.roundabout_radius+p.stop_dist]))<near and c.origin=='N' and c.state!='done' for c in self.cars)
        qS = sum(np.linalg.norm(c.pos - np.array([0.0, -(p.roundabout_radius+p.stop_dist)]))<near and c.origin=='S' and c.state!='done' for c in self.cars)
        qE = sum(np.linalg.norm(c.pos - np.array([p.roundabout_radius+p.stop_dist, 0.0]))<near and c.origin=='E' and c.state!='done' for c in self.cars)
        qW = sum(np.linalg.norm(c.pos - np.array([-(p.roundabout_radius+p.stop_dist), 0.0]))<near and c.origin=='W' and c.state!='done' for c in self.cars)
        return int(qN),int(qS),int(qE),int(qW)

    def step(self):
        self.spawn_poisson('N', self.p.lambda_N)
        self.spawn_poisson('S', self.p.lambda_S)
        self.spawn_poisson('E', self.p.lambda_E)
        self.spawn_poisson('W', self.p.lambda_W)

        self.ctrl.step()
        self.cars.step()

        qN,qS,qE,qW = self.peek_queues()
        self.queue_log.append((self.t,qN,qS,qE,qW,self.ctrl.phase,self.ctrl.sub))
        for c in self.cars:
            if c.state!='done':
                self.pos_log.append((self.t, c.id, c.origin, float(c.pos[0]), float(c.pos[1])))

        self.cars = ap.AgentList(self, [c for c in self.cars if c.state!='done'], Car)

    def end(self):
        self.df_queue = pd.DataFrame(self.queue_log, columns=['t','qN','qS','qE','qW','phase','sub'])
        self.df_arr = pd.DataFrame(self.arrivals_log, columns=['t','dir','veh_id'])
        self.df_dep = pd.DataFrame(self.departures_log, columns=['t','dir','veh_id','delay'])
        self.df_tl  = pd.DataFrame([(t,L['N'],L['S'],L['E'],L['W']) for (t,ph,sub,L) in self.ctrl.timeline],
                                   columns=['t','N','S','E','W'])
        throughput = len(self.df_dep)
        avg_delay = self.df_dep['delay'].mean() if throughput>0 else np.nan
        self.report('throughput', throughput)
        self.report('avg_delay', avg_delay)

        self.df_tl.to_csv('signal_timeline.csv', index=False)
        self.df_queue.to_csv('queues.csv', index=False)
        self.df_arr.to_csv('arrivals.csv', index=False)
        self.df_dep.to_csv('departures.csv', index=False)
        pd.DataFrame(self.pos_log, columns=['t','veh_id','origin','x','y']).to_csv('positions.csv', index=False)

"""# **4) Vehículos y modelo del cruce**"""

def draw_intersection(ax, L, w, r):
    ax.clear(); ax.set_xlim(-L,L); ax.set_ylim(-L,L); ax.set_aspect('equal')
    ax.set_xticks([]); ax.set_yticks([]); ax.set_title("Rotonda simple")
    ax.add_patch(plt.Circle((0,0), r, color='#e0e0e0'))  # rotonda
    ax.add_patch(plt.Rectangle((-L, -w/2), 2*L, w, color='#f0f0f0'))  # eje X
    ax.add_patch(plt.Rectangle((-w/2, -L), w, 2*L, color='#f0f0f0'))  # eje Y

def my_plot(m, ax):
    draw_intersection(ax, m.p.L, m.p.w, m.p.roundabout_radius)
    colors={'R':'#d32f2f','Y':'#f9a825','G':'#388e3c'}
    locs={'N':(0,m.p.roundabout_radius+2),'S':(0,-m.p.roundabout_radius-2),
          'E':(m.p.roundabout_radius+2,0),'W':(-m.p.roundabout_radius-2,0)}
    L = m.ctrl.lights()
    for d,(x,y) in locs.items():
        ax.add_patch(plt.Circle((x,y), 1.2, color=colors.get(L[d],'gray'), zorder=3))
    if len(m.cars)>0:
        xs=[c.pos[0] for c in m.cars]; ys=[c.pos[1] for c in m.cars]
        ax.scatter(xs, ys, s=40, c='#1976d2', edgecolor='k', linewidth=0.5, zorder=4)

fig, ax = plt.subplots(figsize=(6,6))
model = IntersectionModel(PARAMS, controller='fixed')
anim = ap.animate(model, fig, ax, my_plot, steps=200)

from IPython.display import HTML
HTML(anim.to_jshtml())

# --- Ejecutar simulación con plan fijo ---
model = IntersectionModel(PARAMS, controller='fixed')
results = model.run()
print("✅ Simulación terminada")

# --- Archivos CSV generados ---
print("Archivos exportados:")
print("- signal_timeline.csv (señales semafóricas)")
print("- queues.csv (colas por aproximación)")
print("- arrivals.csv (arribos)")
print("- departures.csv (salidas y delays)")
print("- positions.csv (trayectorias de autos)")

# Verificación rápida de tamaños
for fname in ['signal_timeline.csv','queues.csv','arrivals.csv','departures.csv','positions.csv']:
    import os
    if os.path.exists(fname):
        print(fname, " -> ", os.path.getsize(fname), "bytes")