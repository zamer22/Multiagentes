# -*- coding: utf-8 -*-
"""Javier_Copia de Cruce_semaforico.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17IWdcbjM_MiqpdYJO4bfqzyKnOdm3DNJ

## **Dependencias**
"""

!pip install -q agentpy numpy matplotlib seaborn

"""## **Imports y estilo**"""

import agentpy as ap
import numpy as np
from matplotlib import pyplot as plt
import seaborn as sns
import random
sns.set(context="notebook", style="whitegrid")

"""## **Parámetros**"""

params = {
    'steps': 300,          # duración en ticks (1 tick = 1 s)
    'green_ns': 20,        # VERDE para Norte-Sur
    'green_ew': 20,        # VERDE para Este-Oeste
    'yellow': 3,           # ÁMBAR
    'all_red': 1,          # ALL-RED (despeje)
    # Tasas Poisson de arribo (veh/s) por aproximación
    'lambda_N': 0.10, 'lambda_S': 0.10,
    'lambda_E': 0.10, 'lambda_W': 0.10,
    # Cinemática
    'v_free': 7.0,         # m/s
    'headway': 8.0,        # m separación mínima
    # Geometría (intersección centrada en 0,0)
    'L': 80.0,             # media-calzada (desde centro al extremo de dibujo)
    'w': 3.5               # ancho de carril
}

"""## **Controlador de semáforos**"""

class FourWaySignals(ap.Agent):
    """Control alternado: solo UN semáforo activo a la vez en ciclo N-S-E-W."""

    def setup(self, green_ns, green_ew, yellow, all_red):
        self.green_time = int(green_ns)      # Usar green_ns como tiempo verde para cada dirección
        self.yellow_time = int(yellow)       # Tiempo en amarillo
        self.all_red_time = int(all_red)     # Tiempo en rojo general
        self.current_direction = 'N'         # Dirección actual con verde: 'N','S','E','W'
        self.substate = 'G'                  # 'G','Y','AR'
        self.timer = 0
        self.timeline = []      # [(t, {'N':R/Y/G, 'S':..., 'E':..., 'W':...})]

    def lights(self):
        # Todos en rojo por defecto
        L = {d: 'R' for d in ['N','S','E','W']}

        # Solo la dirección actual tiene el estado actual
        if self.substate != 'AR':  # Si no está en rojo general
            L[self.current_direction] = self.substate

        return L

    @property
    def green_dirs(self):
        if self.substate != 'G':
            return set()
        return {self.current_direction}

    def step(self):
        self.timeline.append((self.model.t, self.lights()))

        # Máquina de estados del semáforo
        if self.substate == 'G' and self.timer >= self.green_time:
            # Verde → Amarillo
            self.substate = 'Y'
            self.timer = 0

        elif self.substate == 'Y' and self.timer >= self.yellow_time:
            # Amarillo → Rojo general
            self.substate = 'AR'
            self.timer = 0

        elif self.substate == 'AR' and self.timer >= self.all_red_time:
            # Rojo general → Siguiente dirección en verde
            self.substate = 'G'
            self.timer = 0

            # Ciclo de direcciones: N → S → E → W → N...
            if self.current_direction == 'N':
                self.current_direction = 'S'
            elif self.current_direction == 'S':
                self.current_direction = 'E'
            elif self.current_direction == 'E':
                self.current_direction = 'W'
            else:  # 'W'
                self.current_direction = 'N'

        else:
            # Incrementar timer
            self.timer += 1

"""## **Agente Vehículo**"""

#Modelo antiguo sin Q-learning:
class Car(ap.Agent):
    """Auto en rotonda: entra desde un acceso, circula por la rotonda y sale por el destino correspondiente."""

    def setup(self, origin):
        self.origin = origin            # 'N','S','E','W' (acceso de entrada)
        self.state = 'approach'         # 'approach', 'in_roundabout', 'exiting', 'done', 'stop'
        self.v = self.model.p.v_free
        self.radio_rotonda = self.model.p.L / 3
        w = self.model.p.w
        separacion = w * 0.8  # Separación entre calles

        # Asignar punto de entrada según el origen
        if origin == 'N':  # Desde arriba
            self.pos = np.array([-separacion/2 - w*0.45, self.model.p.L])  # CORREGIDO: signo negativo
            self.angulo = 90
            self.destino_entrada = np.array([-separacion/2 - w*0.45, self.radio_rotonda + 4])
            self.dir = np.array([0, -1])
        elif origin == 'S':  # Desde abajo
            self.pos = np.array([separacion/2 + w*0.45, -self.model.p.L])  # CORREGIDO: signo positivo
            self.angulo = 270
            self.destino_entrada = np.array([separacion/2 + w*0.45, -self.radio_rotonda - 4])
            self.dir = np.array([0, 1])
        elif origin == 'E':  # Desde la derecha
            self.pos = np.array([self.model.p.L, separacion/2 + w*0.45])  # CORREGIDO: signo positivo
            self.angulo = 0
            self.destino_entrada = np.array([self.radio_rotonda + 4, separacion/2 + w*0.45])
            self.dir = np.array([1, 0])
        else:  # 'W' - Desde la izquierda
            self.pos = np.array([-self.model.p.L, -separacion/2 - w*0.45])  # CORREGIDO: signo negativo
            self.angulo = 180
            self.destino_entrada = np.array([-self.radio_rotonda - 4, -separacion/2 - w*0.45])
            self.dir = np.array([-1, 0])

        # Asignar destino final aleatorio (diferente al origen)
        destinos_posibles = ['N', 'S', 'E', 'W']
        destinos_posibles.remove(origin)
        self.destino_final = random.choice(destinos_posibles)

        # Ángulo objetivo para salir de la rotonda - SENTIDO HORARIO
        angulos_salida = {
            'N': 90,    # Salida norte
            'E': 0,     # Salida este
            'S': 270,   # Salida sur
            'W': 180    # Salida oeste
        }
        self.angulo_objetivo = angulos_salida[self.destino_final]

    def dist_to(self, p):
        return np.linalg.norm(self.pos - p)

    def step(self):
      if self.state == 'done':
          # Eliminar vehículo cuando sale completamente de la pantalla
          if (abs(self.pos[0]) > self.model.p.L * 1.2 or
              abs(self.pos[1]) > self.model.p.L * 1.2):
              self.model.remove_agent(self)
          return

      L = self.model.p.L
      w = self.model.p.w
      separacion = w * 0.8

      # VERIFICACIÓN CONTINUA DE SEMÁFOROS - CORRECCIÓN IMPORTANTE
      # Siempre verificar el semáforo, no solo en approach/stop
      lights_dict = self.model.ctrl.lights()
      light_state = lights_dict.get(self.origin, 'R')

      distancia_a_entrada = self.dist_to(self.destino_entrada)

      # Lógica de semáforo para carros que se acercan
      if self.state in ['approach', 'stop'] and distancia_a_entrada < 15:
          if light_state != 'G':
              self.state = 'stop'
              self.v = 0  # Detener completamente
              return
          else:
              # Si el semáforo está verde y estaba detenido, reactivar
              if self.state == 'stop':
                  self.state = 'approach'
                  self.v = self.model.p.v_free  # Restaurar velocidad

      # Si está detenido por semáforo, no hacer nada más
      if self.state == 'stop':
          return

      # Máquina de estados para el movimiento en rotonda
      if self.state == 'approach':
          if self.dist_to(self.destino_entrada) < 1.0:
              self.state = 'in_roundabout'
              # Ajustar ángulo inicial según el origen
              if self.origin == 'N':
                  self.angulo = 90
              elif self.origin == 'S':
                  self.angulo = 270
              elif self.origin == 'E':
                  self.angulo = 0
              else:  # 'W'
                  self.angulo = 180

          else:
              # Movimiento recto hacia el punto de entrada
              direccion = (self.destino_entrada - self.pos)
              distancia = np.linalg.norm(direccion)
              if distancia > 0:
                  direccion_normalizada = direccion / distancia
                  self.pos = self.pos + direccion_normalizada * self.v * 1.0
                  self.dir = direccion_normalizada

      elif self.state == 'in_roundabout':
          # Movimiento circular dentro de la rotonda (sentido HORARIO)
          radio = self.radio_rotonda + 2
          velocidad_angular = self.v / radio * 180 / np.pi

          # AUMENTAR ángulo para movimiento horario
          self.angulo = (self.angulo + velocidad_angular) % 360

          # Convertir a coordenadas cartesianas
          centro = np.array([0, 0])
          self.pos = centro + np.array([
              radio * np.cos(np.radians(self.angulo)),
              radio * np.sin(np.radians(self.angulo))
          ])

          # Actualizar dirección
          self.dir = np.array([
              np.sin(np.radians(self.angulo)),
              -np.cos(np.radians(self.angulo))
          ])

          # Verificar si es momento de salir
          diferencia_angulo = min(
              abs(self.angulo - self.angulo_objetivo),
              360 - abs(self.angulo - self.angulo_objetivo)
          )

          if diferencia_angulo < 10:  # Grados de tolerancia
              self.state = 'exiting'
              # Configurar destino de salida
              if self.destino_final == 'N':
                  self.destino_salida = np.array([-separacion/2 - w*0.45, L])
              elif self.destino_final == 'S':
                  self.destino_salida = np.array([separacion/2 + w*0.45, -L])
              elif self.destino_final == 'E':
                  self.destino_salida = np.array([L, separacion/2 + w*0.45])
              else:  # 'W'
                  self.destino_salida = np.array([-L, -separacion/2 - w*0.45])

      elif self.state == 'exiting':
          # Movimiento recto hacia el destino de salida
          direccion = (self.destino_salida - self.pos)
          distancia = np.linalg.norm(direccion)

          if distancia < 1.0:
              self.state = 'done'
          else:
              direccion_normalizada = direccion / distancia
              self.pos = self.pos + direccion_normalizada * self.v * 1.0
              self.dir = direccion_normalizada

      # Espacio de seguridad con el vehículo adelante
      if self.state != 'stop':
          head = self.model.headway_ahead(self)
          if head is not None:
              gap = np.linalg.norm(head.pos - self.pos)
              if gap < self.model.p.headway:
                  self.v = 0.0  # Reducir velocidad por vehículo adelante
              else: self.v = self.model.p.v_free  # Restaurar velocidad si hay espacio

class Car(ap.Agent):
    """Auto en rotonda: entra desde un acceso, circula por la rotonda y sale por el destino correspondiente."""

    def setup(self, origin):
        self.origin = origin            # 'N','S','E','W' (acceso de entrada)
        self.state = 'approach'         # 'approach', 'in_roundabout', 'exiting', 'done', 'stop'
        self.v = self.model.p.v_free
        self.radio_rotonda = self.model.p.L / 3
        w = self.model.p.w
        separacion = w * 0.8  # Separación entre calles

        # Parámetros de Q-learning
        self.learning_rate = 0.1
        self.discount_factor = 0.9
        self.exploration_rate = 0.3
        self.q_table = {}
        self.actions = ['continue', 'slow_down', 'stop', 'accelerate']
        self.previous_state = None
        self.previous_action = None

        # Asignar punto de entrada según el origen
        if origin == 'N':
            self.pos = np.array([-separacion/2 - w*0.45, self.model.p.L])
            self.angulo = 90
            self.destino_entrada = np.array([-separacion/2 - w*0.45, self.radio_rotonda + 4])
            self.dir = np.array([0, -1])
        elif origin == 'S':
            self.pos = np.array([separacion/2 + w*0.45, -self.model.p.L])
            self.angulo = 270
            self.destino_entrada = np.array([separacion/2 + w*0.45, -self.radio_rotonda - 4])
            self.dir = np.array([0, 1])
        elif origin == 'E':
            self.pos = np.array([self.model.p.L, separacion/2 + w*0.45])
            self.angulo = 0
            self.destino_entrada = np.array([self.radio_rotonda + 4, separacion/2 + w*0.45])
            self.dir = np.array([1, 0])
        else:
            self.pos = np.array([-self.model.p.L, -separacion/2 - w*0.45])
            self.angulo = 180
            self.destino_entrada = np.array([-self.radio_rotonda - 4, -separacion/2 - w*0.45])
            self.dir = np.array([-1, 0])

        # Asignar destino final aleatorio que no sea el del origen
        destinos_posibles = ['N', 'S', 'E', 'W']
        destinos_posibles.remove(origin)
        self.destino_final = random.choice(destinos_posibles)

        # Ángulo objetivo para salir de la rotonda
        angulos_salida = {
            'N': 90,    # Salida norte
            'E': 0,     # Salida este
            'S': 270,   # Salida sur
            'W': 180    # Salida oeste
        }
        self.angulo_objetivo = angulos_salida[self.destino_final]

    # MÉTODOS DE Q-LEARNING
    def get_state(self):
        head = self.model.headway_ahead(self)
        gap = np.linalg.norm(head.pos - self.pos) if head else float('inf')

        # Solo verificar semáforo si está en approach
        light_state_str = 'na'
        if self.state == 'approach':
            lights_dict = self.model.ctrl.lights()
            light_state = lights_dict.get(self.origin, 'R')
            light_state_str = 'green' if light_state == 'G' else 'red'

        # Discretizar gap
        if gap < self.model.p.headway:
            gap_state = 'very_close'
        elif gap < self.model.p.headway * 2:
            gap_state = 'close'
        else:
            gap_state = 'far'

        return f"{gap_state}_{light_state_str}_{self.state}"

    def choose_action(self, state):
        """Elige una acción usando política epsilon-greedy."""
        if state not in self.q_table:
            self.q_table[state] = {action: 0.0 for action in self.actions}

        if random.random() < self.exploration_rate:
            return random.choice(self.actions)
        else:
            return max(self.q_table[state].items(), key=lambda x: x[1])[0]

    def update_q_value(self, state, action, reward, next_state):
        """Actualiza el valor Q."""
        if state not in self.q_table:
            self.q_table[state] = {a: 0.0 for a in self.actions}
        if next_state not in self.q_table:
            self.q_table[next_state] = {a: 0.0 for a in self.actions}

        best_next_action_value = max(self.q_table[next_state].values())
        current_q_value = self.q_table[state][action]

        new_q_value = current_q_value + self.learning_rate * (
            reward + self.discount_factor * best_next_action_value - current_q_value
        )

        self.q_table[state][action] = new_q_value

    def get_reward(self, state, action):
        """Calcula la recompensa basada en el estado y acción."""
        reward = 0

        # Recompensa por progreso
        if self.state == 'in_roundabout':
            reward += 0.1

        # Penalizar paradas innecesarias en rotonda
        if self.state == 'in_roundabout' and action == 'stop':
            reward -= 2

        # Recompensa por mantener velocidad
        if self.v > self.model.p.v_free * 0.7:
            reward += 0.3

        # Penalizar proximidad peligrosa
        head = self.model.headway_ahead(self)
        if head:
            gap = np.linalg.norm(head.pos - self.pos)
            if gap < self.model.p.headway:
                reward -= 5

        return reward

    def apply_action(self, action):
        """Aplica la acción del vehículo."""
        if action == 'continue':
            self.v = min(self.v + 0.1, self.model.p.v_free)
        elif action == 'slow_down':
            self.v = max(self.v - 0.5, 0)
        elif action == 'stop':
            self.v = 0
        elif action == 'accelerate':
            self.v = min(self.v + 0.8, self.model.p.v_free * 1.2)

    def dist_to(self, p):
        return np.linalg.norm(self.pos - p)

    def step(self):
        if self.state == 'done':
            # Eliminar vehículo cuando sale completamente de la pantalla
            if (abs(self.pos[0]) > self.model.p.L * 1.2 or
                abs(self.pos[1]) > self.model.p.L * 1.2):
                self.model.remove_agent(self)
            return

        # (Q-LEARNING) Obtener estado y elegir acción
        current_state = self.get_state()
        action = self.choose_action(current_state)
        self.apply_action(action)
        reward = self.get_reward(current_state, action)

        L = self.model.p.L
        w = self.model.p.w
        separacion = w * 0.8

        # Verificar el semáforo
        lights_dict = self.model.ctrl.lights()
        light_state = lights_dict.get(self.origin, 'R')

        distancia_a_entrada = self.dist_to(self.destino_entrada)

        # Lógica de semáforo para carros que se acercan
        if self.state in ['approach', 'stop'] and distancia_a_entrada < 15:
            if light_state != 'G':
                self.state = 'stop'
                self.v = 0  # Detener completamente
                # Actualizar Q-value antes de retornar
                next_state = self.get_state()
                if self.previous_state is not None and self.previous_action is not None:
                    self.update_q_value(self.previous_state, self.previous_action, reward, next_state)
                self.previous_state = current_state
                self.previous_action = action
                return
            else:
                # Si el semáforo está verde y estaba detenido, reactivar
                if self.state == 'stop':
                    self.state = 'approach'
                    self.v = self.model.p.v_free  # Restaurar velocidad

        # Si está detenido por semáforo, no hacer nada más
        if self.state == 'stop':
            # Actualizar Q-value antes de retornar
            next_state = self.get_state()
            if self.previous_state is not None and self.previous_action is not None:
                self.update_q_value(self.previous_state, self.previous_action, reward, next_state)
            self.previous_state = current_state
            self.previous_action = action
            return

        # Máquina de estados para el movimiento en rotonda
        if self.state == 'approach':
            if self.dist_to(self.destino_entrada) < 1.0:
                self.state = 'in_roundabout'
                # Ajustar ángulo inicial según el origen
                if self.origin == 'N':
                    self.angulo = 90
                elif self.origin == 'S':
                    self.angulo = 270
                elif self.origin == 'E':
                    self.angulo = 0
                else:  # 'W'
                    self.angulo = 180

            else:
                # Movimiento recto hacia el punto de entrada
                direccion = (self.destino_entrada - self.pos)
                distancia = np.linalg.norm(direccion)
                if distancia > 0:
                    direccion_normalizada = direccion / distancia
                    self.pos = self.pos + direccion_normalizada * self.v * 1.0
                    self.dir = direccion_normalizada

        elif self.state == 'in_roundabout':
            # Movimiento circular dentro de la rotonda (sentido HORARIO)
            radio = self.radio_rotonda + 2
            velocidad_angular = self.v / radio * 180 / np.pi

            # AUMENTAR ángulo para movimiento horario
            self.angulo = (self.angulo + velocidad_angular) % 360

            # Convertir a coordenadas cartesianas
            centro = np.array([0, 0])
            self.pos = centro + np.array([
                radio * np.cos(np.radians(self.angulo)),
                radio * np.sin(np.radians(self.angulo))
            ])

            # Actualizar dirección
            self.dir = np.array([
                np.sin(np.radians(self.angulo)),
                -np.cos(np.radians(self.angulo))
            ])

            # Verificar si es momento de salir
            diferencia_angulo = min(
                abs(self.angulo - self.angulo_objetivo),
                360 - abs(self.angulo - self.angulo_objetivo)
            )

            if diferencia_angulo < 10:  # Configurar destino de salida
                self.state = 'exiting'
                if self.destino_final == 'N':
                    self.destino_salida = np.array([-separacion/2 + w, L])
                elif self.destino_final == 'S':
                    self.destino_salida = np.array([separacion/2 - w, -L])
                elif self.destino_final == 'E':
                    self.destino_salida = np.array([L, separacion/2 - w])
                else:  # 'W'
                    self.destino_salida = np.array([-L, -separacion/2 + w])

        elif self.state == 'exiting':
            # Movimiento recto hacia el destino de salida
            direccion = (self.destino_salida - self.pos)
            distancia = np.linalg.norm(direccion)

            if distancia < 1.0:
                self.state = 'done'
            else:
                direccion_normalizada = direccion / distancia
                self.pos = self.pos + direccion_normalizada * self.v * 1.0
                self.dir = direccion_normalizada

        # Espacio de seguridad con el vehículo adelante
        if self.state != 'stop':
            head = self.model.headway_ahead(self)
            if head is not None:
                gap = np.linalg.norm(head.pos - self.pos)
                if gap < self.model.p.headway:
                    self.v = 0.0  # Reducir velocidad por vehículo adelante
                else:
                    self.v = self.model.p.v_free  # Restaurar velocidad si hay espacio

        # Q-LEARNING: Actualizar valores después del movimiento
        next_state = self.get_state()
        if self.previous_state is not None and self.previous_action is not None:
            self.update_q_value(self.previous_state, self.previous_action, reward, next_state)

        self.previous_state = current_state
        self.previous_action = action

"""## **Modelo con arribos Poisson y listas de agentes**"""

class FourWayModel(ap.Model):

    def setup(self):
        p = self.p
        self.ctrl = FourWaySignals(self, p.green_ns, p.green_ew, p.yellow, p.all_red)
        self.cars = ap.AgentList(self, 0, Car)
        self.spawn_counts = {d:0 for d in ['N','S','E','W']}
        # Log para análisis si quieres después
        self.log = []

    def headway_ahead(self, me):
        """Líder en el mismo carril y sentido, si existe."""
        same = [c for c in self.cars if c is not me and np.allclose(c.dir, me.dir)]
        if not same: return None
        # candidato delante si el vector a él está en dirección de me.dir y más adelante
        ahead = []
        for c in same:
            v = c.pos - me.pos
            proj = np.dot(v, me.dir)
            if proj > 0:  # adelante
                ahead.append((proj, c))
        if not ahead: return None
        return min(ahead, key=lambda x: x[0])[1]

    def spawn_poisson(self, origin, lam):
        k = np.random.poisson(lam)
        for _ in range(k):
            self.cars.append(Car(self, origin=origin))
            self.spawn_counts[origin]+=1

    def step(self):
        # 1) arribos
        self.spawn_poisson('N', self.p.lambda_N)
        self.spawn_poisson('S', self.p.lambda_S)
        self.spawn_poisson('E', self.p.lambda_E)
        self.spawn_poisson('W', self.p.lambda_W)

        # 2) señales
        self.ctrl.step()

        # 3) autos
        self.cars.step()

        # 4) limpieza de autos terminados (opcional)
        self.cars = ap.AgentList(self, [c for c in self.cars if c.state != 'done'], Car)

"""## **Función de animación (animation_plot)**"""

def draw_roundabout(ax, L, w):
    ax.clear()
    ax.set_xlim(-L, L); ax.set_ylim(-L, L)
    ax.set_aspect('equal')
    ax.set_xticks([]); ax.set_yticks([])
    ax.set_title(f"Rotonda | t = {model.t}s")

    r = L / 3

    # Dibujar la rotonda
    ax.add_patch(plt.Circle((0, 0), r, color='#2e8b57', zorder=0))

    # Dibujar anillo de circulación
    ax.add_patch(plt.Circle((0, 0), r + 4, fill=False, edgecolor='#696969', linewidth=8, zorder=0))

    separacion_calles = w * 0.8
    ancho_calle = w * 0.9

    # Calle de entrada superior izquierda
    ax.add_patch(plt.Rectangle((-separacion_calles/2 - ancho_calle, r+4), ancho_calle, L-r-4, color='#696969', zorder=0))
    # Calle de salida superior derecha
    ax.add_patch(plt.Rectangle((separacion_calles/2, r+4), ancho_calle, L-r-4, color='#696969', zorder=0))

    # Calle salida inferior izquierda
    ax.add_patch(plt.Rectangle((-separacion_calles/2 - ancho_calle, -L), ancho_calle, L-r-4, color='#696969', zorder=0))
    # Calle entrada inferior derecha
    ax.add_patch(plt.Rectangle((separacion_calles/2, -L), ancho_calle, L-r-4, color='#696969', zorder=0))

    # Calle horizontal derecha
    sep_derecha = w * 1.4
    ax.add_patch(plt.Rectangle((r+4, -sep_derecha/2), L-r-4, sep_derecha, color='#696969', zorder=0))

    # Calle horizontal izquierda
    ax.add_patch(plt.Rectangle((-L, -w/2), L-r-4, w, color='#696969', zorder=0))

    # Para calles superiores izquierdas
    x_superior_izq = -separacion_calles/2 - ancho_calle/2
    ax.plot([x_superior_izq, x_superior_izq], [r+4, L], color='white', lw=1, ls='--', zorder=1)

    # Para calles superiores derechas
    x_superior_der = separacion_calles/2 + ancho_calle/2
    ax.plot([x_superior_der, x_superior_der], [r+4, L], color='white', lw=1, ls='--', zorder=1)

    # Para calles inferiores izquierdas
    x_inferior_izq = -separacion_calles/2 - ancho_calle/2
    ax.plot([x_inferior_izq, x_inferior_izq], [-L, -r-4], color='white', lw=1, ls='--', zorder=1)

    # Para calles inferiores derechas
    x_inferior_der = separacion_calles/2 + ancho_calle/2
    ax.plot([x_inferior_der, x_inferior_der], [-L, -r-4], color='white', lw=1, ls='--', zorder=1)

    # Líneas horizontales para calles laterales
    ax.plot([r+4, L], [-sep_derecha/4, -sep_derecha/4], color='white', lw=1, ls='--', zorder=1)
    ax.plot([r+4, L], [sep_derecha/4, sep_derecha/4], color='white', lw=1, ls='--', zorder=1)
    ax.plot([-r-4, -L], [-w/4, -w/4], color='white', lw=1, ls='--', zorder=1)
    ax.plot([-r-4, -L], [w/4, w/4], color='white', lw=1, ls='--', zorder=1)

    # Líneas de yield (ceda el paso) en las entradas
    for angle in [45, 135, 225, 315]:
        x = (r + 8) * np.cos(np.radians(angle))
        y = (r + 8) * np.sin(np.radians(angle))
        ax.plot([x, x], [y, y], 'o', markersize=5, color='white', alpha=0.8, zorder=1)

def my_plot(m, ax):
    L, w = m.p.L, m.p.w
    draw_roundabout(ax, L, w)
    lights = m.ctrl.lights()
    color_map = {'R':'#d32f2f', 'Y':'#f9a825', 'G':'#388e3c', 'AR':'#000000'}

    # Ubicaciones específicas para semáforos en la rotonda
    r = L / 3
    separacion_calles = w * 0.8
    ancho_calle = w * 0.9

    locs = {
        'N': (-separacion_calles/2 - ancho_calle/2, r + 8),    # Entrada norte
        'S': (separacion_calles/2 + ancho_calle/2, -r - 8),    # Entrada sur
        'E': (r + 8, separacion_calles/4),                     # Entrada este
        'W': (-r - 8, w/4)                                     # Entrada oeste
    }

    for d, (x, y) in locs.items():
        ax.add_patch(plt.Circle((x, y), 2.5, color=color_map[lights[d]], zorder=5))
        ax.add_patch(plt.Circle((x, y), 2.5, fill=False, edgecolor='black', linewidth=1, zorder=5))

    # Autos
    if len(m.cars) > 0:
        xs = [c.pos[0] for c in m.cars]
        ys = [c.pos[1] for c in m.cars]
        cs = ['#1976d2' if c.state!='stop' else '#455a64' for c in m.cars]
        ax.scatter(xs, ys, s=40, c=cs, edgecolor='k', linewidth=0.5, zorder=4)

"""## **Correr animación**"""

fig, ax = plt.subplots(figsize=(6,6))
model = FourWayModel(params)
anim = ap.animate(model, fig, ax, my_plot)
from IPython.display import HTML
HTML(anim.to_jshtml())