# -*- coding: utf-8 -*-
"""M3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1csDQKC734e-ms1mwNRFiKKwDwZV_-rFQ

## **Dependencias**
"""

!pip install -q agentpy numpy matplotlib seaborn

"""## **Imports y estilo**"""

import agentpy as ap
import numpy as np
from matplotlib import pyplot as plt
import seaborn as sns
sns.set(context="notebook", style="whitegrid")

"""## **Parámetros**"""

params = {
    'steps': 900,
    'Gmin': 10,
    'Gmax': 30,
    'Y': 3,
    'AR': 1,
    'theta': 2,

    'arrival_rates': {
        'W_in': 0.10,
        'S_in': 0.12,
        'E_in': 0.08,
        'N_in': 0.11,
    },

    'turn_probs': {
        'W_in': [0.30, 0.50, 0.20],
        'S_in': [0.25, 0.50, 0.25],
        'E_in': [0.30, 0.45, 0.25],
        'N_in': [0.35, 0.45, 0.20],
    },

    'uturn_prob': {
        'N_in': 0.15,
        'S_in': 0.15,
        'E_in': 0.00,
        'W_in': 0.00,
    },

    'v_free': 6.5,
    'v_ring': 5.0,
    'headway': 7.0,

    'R': 18.0,
    'w': 3.5,
    'L': 90.0,

    'Ru': 7.0,
    'offset_u': 14.0,

    'signals': [
        'W_in', 'S_in', 'E_in', 'N_in',
        'C_N', 'C_S',
        'N_out', 'S_out'
    ],

    'figsize': (7,7),
}

CARD_ANGLES = {'E': 0, 'N': np.pi/2, 'W': np.pi, 'S': 3*np.pi/2}
def base_dir_of(lane): return lane.split('_')[0]
def angle_of_lane(lane): return CARD_ANGLES[base_dir_of(lane)]

EXIT_SEQUENCE = {
    'N_in': ['S','E','N'],
    'E_in': ['N','S','E'],
    'S_in': ['E','N','S'],
    'W_in': ['S','E','N'],
}

"""## **Controlador de semáforos**"""

class MultiSignalController(ap.Agent):
    def setup(self, signals, Gmin, Gmax, Y, AR, theta):
        self.signals = list(signals)
        self.Gmin, self.Gmax = int(Gmin), int(Gmax)
        self.Y, self.AR = int(Y), int(AR)
        self.theta = theta
        self.state = {s:{'sub':'G','t_in':0} for s in self.signals}
        self.timeline = []

    def lights(self):
        return {s: self.state[s]['sub'] for s in self.signals}

    def step(self, qlens, ring_counts, u_counts):
        self.timeline.append((self.model.t, self.lights()))
        for s in self.signals:
            st = self.state[s]
            if s.endswith('_in'):
                local_q = qlens.get(s, 0)
            elif s.endswith('_out'):
                local_q = ring_counts.get(s, 0)
            elif s in ('C_N','C_S'):
                local_q = ring_counts.get(s, 0)
            else:
                local_q = 0

            others = 0
            for s2 in self.signals:
                if s2 == s: continue
                if s2.endswith('_in'):
                    others += qlens.get(s2, 0)
                elif s2.endswith('_out'):
                    others += ring_counts.get(s2, 0)
                elif s2 in ('C_N','C_S'):
                    others += ring_counts.get(s2, 0)

            if st['sub'] == 'G':
                if (local_q > (others + self.theta)) and (st['t_in'] < self.Gmax):
                    st['t_in'] += 1
                elif st['t_in'] >= self.Gmin:
                    st['sub'] = 'Y'; st['t_in'] = 0
                else:
                    st['t_in'] += 1
            elif st['sub'] == 'Y':
                if st['t_in'] >= self.Y:
                    st['sub'] = 'AR'; st['t_in'] = 0
                else:
                    st['t_in'] += 1
            else:
                if st['t_in'] >= self.AR:
                    st['sub'] = 'G'; st['t_in'] = 0
                else:
                    st['t_in'] += 1
            self.state[s] = st

"""## **Agente Vehículo**"""

class Car(ap.Agent):
    def setup(self, origin, route, exit_steps_ahead=None):
        self.origin = origin
        self.route = route
        self.exit_steps = int(exit_steps_ahead) if exit_steps_ahead else 0
        self.state = 'approach'
        p = self.model.p
        self.v_free, self.v_ring = p.v_free, p.v_ring
        self.R, self.w, self.L = p.R, p.w, p.L
        self.Ru, self.offset_u = p.Ru, p.offset_u

        a0 = angle_of_lane(origin)
        n = np.array([-np.sin(a0), np.cos(a0)])
        lateral_sep = 2.0*self.w
        in_off = +lateral_sep if base_dir_of(origin) in ('N','S','E') else 0.0
        self.pos = np.array([ p.L*np.cos(a0), p.L*np.sin(a0) ]) + n*in_off
        self.dir = -np.array([np.cos(a0), np.sin(a0)])
        self.stop_r = self.R + 1.6*self.w
        self.stop_pos = np.array([ self.stop_r*np.cos(a0), self.stop_r*np.sin(a0) ]) + n*in_off

        if base_dir_of(origin) == 'N':
            self.uctr = np.array([0.0, self.R + self.w/2 + self.offset_u])
        elif base_dir_of(origin) == 'S':
            self.uctr = np.array([0.0, -(self.R + self.w/2 + self.offset_u)])
        else:
            self.uctr = None
        self.u_theta = 0.0

        if route == 'ring':
            seq = EXIT_SEQUENCE[origin]
            dest = seq[(exit_steps_ahead-1) % len(seq)]
            self.exit_card = dest
            self.arc_len = exit_steps_ahead*(np.pi/2)
        else:
            self.exit_card = base_dir_of(origin)
            self.arc_len = 0

        self.arc_prog = 0.0
        self.t_spawn = self.model.t
        self.t_enter, self.t_exit = None, None

    def dist_to(self, p): return np.linalg.norm(self.pos - p)

    def leader_gap(self):
        same = [c for c in self.model.cars if c is not self and getattr(c,'origin',None)==self.origin and c.state in ('approach','stop','ring','uturn')]
        if not same: return None
        myd = np.linalg.norm(self.pos)
        ahead = [ (myd - np.linalg.norm(c.pos)) for c in same if np.linalg.norm(c.pos) < myd ]
        return min(ahead) if ahead else None

    def step(self):
        if self.state == 'done': return
        if self.state == 'exit' and np.linalg.norm(self.pos) > self.L-1:
            self.state = 'done'; self.t_exit=self.model.t; return
        if self.state == 'uturn' and self.uctr is not None and np.linalg.norm(self.pos-self.uctr) > self.Ru+self.L/2:
            self.state = 'done'; self.t_exit=self.model.t; return

        if self.state in ('approach','stop'):
            lights = self.model.ctrl.lights()
            light_here = lights.get(self.origin,'G')
            near = self.dist_to(self.stop_pos)<4.0
            if near and self.route!='uturn' and light_here!='G':
                self.state='stop'; return

            vmax=self.v_free
            gap=self.leader_gap()
            if gap is not None and gap<self.model.p.headway: vmax=0.0
            nxt=self.pos+self.dir*vmax
            if np.linalg.norm(nxt)<=self.R+0.01:
                if self.route=='uturn' and self.uctr is not None:
                    self.state='uturn'; self.t_enter=self.model.t
                    if base_dir_of(self.origin)=='N': start_ang=-np.pi/2
                    else: start_ang=np.pi/2
                    self.u_theta=0.0; self.u_start=start_ang; self.u_dir=1.0
                    self.pos=self.uctr+np.array([self.Ru*np.cos(start_ang), self.Ru*np.sin(start_ang)])
                else:
                    self.state='ring'; self.t_enter=self.model.t; self.arc_prog=0.0
                    ang=angle_of_lane(self.origin)
                    n=np.array([-np.sin(ang), np.cos(ang)])
                    in_off=+1.5*self.w if base_dir_of(self.origin) in ('N','S','E') else 0.0
                    self.pos=np.array([self.R*np.cos(ang), self.R*np.sin(ang)])+n*in_off
                return
            else: self.pos=nxt; return

        if self.state=='ring':
            dtheta=self.v_ring/self.R
            if not self.model.safe_ring_advance(self,dtheta): dtheta=0.0
            self.arc_prog+=dtheta
            ang=(angle_of_lane(self.origin)+self.arc_prog)%(2*np.pi)
            n=np.array([-np.sin(ang), np.cos(ang)])
            in_off=+1.0*self.w if base_dir_of(self.origin) in ('N','S','E') else 0.0
            self.pos=np.array([self.R*np.cos(ang), self.R*np.sin(ang)])+n*in_off
            if self.arc_prog>=self.arc_len-1e-6:
                self.state='exit'
                a_out=CARD_ANGLES[self.exit_card]
                n_out=np.array([-np.sin(a_out), np.cos(a_out)])
                out_off=-1.0*self.w if self.exit_card in ('N','S','E') else 0.0
                self.pos=np.array([self.R*np.cos(a_out), self.R*np.sin(a_out)])+n_out*out_off
                self.exit_dir=np.array([np.cos(a_out), np.sin(a_out)])
            return

        if self.state=='uturn':
            dth=self.v_free/self.Ru
            self.u_theta+=dth
            curr=self.u_start+self.u_dir*self.u_theta
            self.pos=self.uctr+np.array([self.Ru*np.cos(curr), self.Ru*np.sin(curr)])
            if self.u_theta>=np.pi-1e-3:
                self.state='exit'
                a_out=CARD_ANGLES[self.exit_card]
                n_out=np.array([-np.sin(a_out), np.cos(a_out)])
                out_off=-1.0*self.w
                self.pos=np.array([self.R*np.cos(a_out), self.R*np.sin(a_out)])+n_out*out_off
                self.exit_dir=np.array([np.cos(a_out), np.sin(a_out)])
            return

        if self.state=='exit':
            self.pos=self.pos+self.exit_dir*self.v_free; return

"""## **Modelo con arribos Poisson y listas de agentes**"""

class RoundaboutModel(ap.Model):
    def setup(self):
        p=self.p
        self.ctrl=MultiSignalController(self,p.signals,p.Gmin,p.Gmax,p.Y,p.AR,p.theta)
        self.cars=ap.AgentList(self,[],Car)
        self.spawn_counts={s:0 for s in p.arrival_rates.keys()}
        self.done_times=[]
        self.max_queue={k:0 for k in p.arrival_rates.keys()}
        self.throughput=0

    def queue_lengths(self):
        q={k:0 for k in self.p.arrival_rates.keys()}
        for c in self.cars:
            if getattr(c,'origin',None) in q:
                if c.state in ('approach','stop') and c.dist_to(c.stop_pos)<30.0:
                    q[c.origin]+=1
        return q

    def ring_counts(self):
        counts={'C_N':0,'C_S':0,'N_out':0,'S_out':0,'E_out':0}
        for c in self.cars:
            if c.state=='ring':
                ang=np.arctan2(c.pos[1],c.pos[0])%(2*np.pi)
                if abs((ang-CARD_ANGLES['N'])%(2*np.pi))<0.25: counts['C_N']+=1
                if abs((ang-CARD_ANGLES['S'])%(2*np.pi))<0.25: counts['C_S']+=1
                counts[f"{c.exit_card}_out"]+=1
        return counts

    def uturn_counts(self):
        counts={'U_N':0,'U_S':0}
        for c in self.cars:
            if c.state in ('approach','stop') and c.route=='uturn':
                if base_dir_of(c.origin)=='N': counts['U_N']+=1
                if base_dir_of(c.origin)=='S': counts['U_S']+=1
        return counts

    def safe_ring_advance(self,me,delta_theta):
        my_ang=(angle_of_lane(me.origin)+me.arc_prog)%(2*np.pi)
        min_ang=self.p.headway/self.p.R
        for c in self.cars:
            if c is me or c.state!='ring': continue
            ang_c=(angle_of_lane(c.origin)+c.arc_prog)%(2*np.pi)
            rel=(ang_c-my_ang)%(2*np.pi)
            if 0<rel<min_ang: return False
        return True

    def spawn_poisson(self,lane,lam):
        k=np.random.poisson(lam)
        probs=self.p.turn_probs[lane]
        put=self.p.uturn_prob.get(lane,0.0)
        for _ in range(k):
            if np.random.rand()<put:
                car=Car(self,origin=lane,route='uturn')
            else:
                exit_ahead=np.random.choice([1,2,3],p=probs)
                car=Car(self,origin=lane,route='ring',exit_steps_ahead=exit_ahead)
            self.cars.append(car); self.spawn_counts[lane]+=1

    def step(self):
        for lane,lam in self.p.arrival_rates.items(): self.spawn_poisson(lane,lam)
        q=self.queue_lengths(); rc=self.ring_counts(); uc=self.uturn_counts()
        for k in q: self.max_queue[k]=max(self.max_queue[k],q[k])
        self.ctrl.step(q,rc,uc); self.cars.step()
        survivors=[]
        for c in self.cars:
            if c.state=='done' and c.t_exit is not None:
                delay=(c.t_enter or c.t_exit)-c.t_spawn
                tt=c.t_exit-c.t_spawn
                self.done_times.append((delay,tt)); self.throughput+=1
            else: survivors.append(c)
        self.cars=ap.AgentList(self,survivors,Car)

"""## **Función de animación (animation_plot)**"""

def draw_roundabout(ax, R, w, L, p, t, model):
    ax.clear()
    ax.set_xlim(-L, L); ax.set_ylim(-L, L); ax.set_aspect('equal')
    ax.set_xticks([]); ax.set_yticks([])
    ax.set_title(f"Rotonda | t = {t}s")

    # Anillo
    ring_out = plt.Circle((0,0), R + w/2, color='#d8d8d8', zorder=0)
    ring_in  = plt.Circle((0,0), R - w/2, color='white', zorder=1)
    ax.add_patch(ring_out); ax.add_patch(ring_in)

    # Carriles de aproximación
    lateral_sep = 2.0 * w
    for base, ang in CARD_ANGLES.items():
        n = np.array([-np.sin(ang), np.cos(ang)])

        if base in ('N','S','E'):
            out_off = -lateral_sep
            in_off  = +lateral_sep
            lw = 6
            # OUT
            x0_out,y0_out = (R + 1.7*w)*np.cos(ang) + n[0]*out_off, (R + 1.7*w)*np.sin(ang) + n[1]*out_off
            x1_out,y1_out = L*np.cos(ang) + n[0]*out_off, L*np.sin(ang) + n[1]*out_off
            ax.plot([x0_out,x1_out],[y0_out,y1_out], color='#d8d8d8', lw=lw, solid_capstyle='butt', zorder=0)
            # IN
            x0_in,y0_in = (R + 1.7*w)*np.cos(ang) + n[0]*in_off, (R + 1.7*w)*np.sin(ang) + n[1]*in_off
            x1_in,y1_in = L*np.cos(ang) + n[0]*in_off, L*np.sin(ang) + n[1]*in_off
            ax.plot([x0_in,x1_in],[y0_in,y1_in], color='#d8d8d8', lw=lw, solid_capstyle='butt', zorder=0)
            # Stoplines
            stop_r = R + 1.6*w
            xs_in, ys_in = stop_r*np.cos(ang) + n[0]*in_off, stop_r*np.sin(ang) + n[1]*in_off
            xs_out, ys_out = stop_r*np.cos(ang) + n[0]*out_off, stop_r*np.sin(ang) + n[1]*out_off
            nn = np.array([-np.sin(ang), np.cos(ang)])
            ax.plot([xs_in-2*nn[0], xs_in+2*nn[0]],[ys_in-2*nn[1], ys_in+2*nn[1]], color='yellow', lw=2, zorder=3)
            ax.plot([xs_out-2*nn[0], xs_out+2*nn[0]],[ys_out-2*nn[1], ys_out+2*nn[1]], color='yellow', lw=2, zorder=3)
            # Franja roja semáforo IN
            ax.plot([xs_in-2*nn[0], xs_in+2*nn[0]],[ys_in-2*nn[1], ys_in+2*nn[1]], color='red', lw=3, zorder=4)
        else:
            # Oeste solo IN
            in_off = 0.4 * w
            x0_in,y0_in = (R + 1.7*w)*np.cos(ang) + n[0]*in_off, (R + 1.7*w)*np.sin(ang) + n[1]*in_off
            x1_in,y1_in = L*np.cos(ang) + n[0]*in_off, L*np.sin(ang) + n[1]*in_off
            ax.plot([x0_in,x1_in],[y0_in,y1_in], color='#d8d8d8', lw=6, solid_capstyle='butt', zorder=0)
            stop_r = R + 1.6*w
            xs_in, ys_in = stop_r*np.cos(ang) + n[0]*in_off, stop_r*np.sin(ang) + n[1]*in_off
            nn = np.array([-np.sin(ang), np.cos(ang)])
            ax.plot([xs_in-2*nn[0], xs_in+2*nn[0]],[ys_in-2*nn[1], ys_in+2*nn[1]], color='yellow', lw=2, zorder=3)
            ax.plot([xs_in-2*nn[0], xs_in+2*nn[0]],[ys_in-2*nn[1], ys_in+2*nn[1]], color='red', lw=3, zorder=4)

    # Barreras interiores (C_N, C_S)
    for card in ['N','S']:
        ang = CARD_ANGLES[card]
        n = np.array([-np.sin(ang), np.cos(ang)])
        m = np.array([np.cos(ang), np.sin(ang)]) * R
        ax.plot([m[0]-2*n[0], m[0]+2*n[0]],[m[1]-2*n[1], m[1]+2*n[1]], color='red', lw=3, zorder=3)

    # U-turns
    Ru, off = p.Ru, p.offset_u
    ctrN = np.array([0.0, R + w/2 + off])
    th = np.linspace(-np.pi, 0, 80)
    ax.plot(ctrN[0] + Ru*np.cos(th), ctrN[1] + Ru*np.sin(th), color='#b0bec5', lw=6, zorder=1)
    ctrS = np.array([0.0, -(R + w/2 + off)])
    th = np.linspace(0, np.pi, 80)
    ax.plot(ctrS[0] + Ru*np.cos(th), ctrS[1] + Ru*np.sin(th), color='#b0bec5', lw=6, zorder=1)

    # Semáforos
    sig_pos = {}
    for base, ang in CARD_ANGLES.items():
        n = np.array([-np.sin(ang), np.cos(ang)])
        if base in ('N','S','E'):
            in_off = +1.0 * w
        else:
            in_off = 0.4 * w
        sig_pos[f"{base}_in"] = ((R+2.0*w)*np.cos(ang) + n[0]*in_off,
                                 (R+2.0*w)*np.sin(ang) + n[1]*in_off)
    for card in ('N','S'):
        ang = CARD_ANGLES[card]
        n = np.array([-np.sin(ang), np.cos(ang)])
        out_off = -1.0 * w
        sig_pos[f"{card}_out"] = ((R-1.2*w)*np.cos(ang) + n[0]*out_off,
                                  (R-1.2*w)*np.sin(ang) + n[1]*out_off)
    sig_pos['C_N'] = (0.0, R*0.55 + 1.0*w)
    sig_pos['C_S'] = (0.0, -R*0.55 - 1.0*w)

    lights = model.ctrl.lights()
    color_map = {'R':'#d32f2f','Y':'#f9a825','G':'#388e3c','AR':'#000000'}
    for s,pos in sig_pos.items():
        if s not in lights: continue
        x,y = pos
        ax.add_patch(plt.Circle((x,y), 1.2, color=color_map.get(lights[s],'#777'), zorder=6))

def my_plot(m, ax):
    p = m.p
    draw_roundabout(ax, p.R, p.w, p.L, p, m.t, m)
    if len(m.cars) > 0:
        xs = [c.pos[0] for c in m.cars]
        ys = [c.pos[1] for c in m.cars]
        colors = []
        for c in m.cars:
            if c.route == 'uturn':
                base = '#ff5722'  # Naranja para U-turns
            else:
                base = '#1976d2'  # Azul para normales
            colors.append({
                'approach': base,
                'stop': '#455a64',
                'ring': '#7b1fa2',
                'exit': '#00796b',
                'uturn': base
            }.get(c.state, base))
        ax.scatter(xs, ys, s=36, c=colors, edgecolor='k', linewidth=0.3, zorder=7)

"""## **Correr animación**"""

fig, ax = plt.subplots(figsize=params['figsize'])
model = RoundaboutModel(params)
anim = ap.animate(model, fig, ax, my_plot)
from IPython.display import HTML
HTML(anim.to_jshtml())

delays = [d for d,_ in model.done_times] or [np.nan]
tts    = [tt for _,tt in model.done_times] or [np.nan]

print(f"Vehículos descargados (throughput): {model.throughput}")
print(f"Delay promedio (s): {np.nanmean(delays):.2f}")
print(f"Tiempo total de viaje promedio (s): {np.nanmean(tts):.2f}")
print("Cola máxima por aproximación (veh):", model.max_queue)

plt.figure(figsize=(5,3))
plt.bar(list(model.max_queue.keys()), [model.max_queue[k] for k in model.max_queue])
plt.title('Cola máxima por aproximación'); plt.ylabel('veh'); plt.show()

if model.done_times:
    plt.figure(figsize=(5,3))
    plt.hist([d for d,_ in model.done_times], bins=20)
    plt.title('Histograma de delays (s)'); plt.xlabel('delay'); plt.show()

"""Se usa MDP con estados y acciones discretas con recompensa para incentivar throughput y penalizar delay. Se usa Q-learning para adaptarse a diferentes flujos de tráfico y reducir el delay promedio y colas máximas."""